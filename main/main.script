require "managers.position_manager"
require "managers.text_manager"
require "levels.level_1.level_1"
local input_manager = require "managers/input_manager"
local timer = require "vendor/timer"
local _ = require('vendor.moses')
local C = require('main/constants')
local Map = require('lib.map')
local timers = {}

function init(self)
    msg.post("/camera#camera", "acquire_camera_focus")
    msg.post(".", "acquire_input_focus")

    sprite.set_constant("/barbican__flat__bedroom#map", "tint", C.OFF_TINT)
    sprite.set_constant("/barbican__flat__lounge#map", "tint", C.OFF_TINT)
    sprite.set_constant("/"..get_current_map_name().."#map", "tint", C.ON_TINT)
    sprite.set_constant("/player#sprite", "tint", C.ON_TINT)

    local pos = go.get_position("/player")
    set_player_position(px_to_tx(pos.x), py_to_ty(pos.y), "south");
end

function update(self, dt)
    timer.update(timers, dt)
end

function on_input(self, action_id, action)
    input_manager.accept_input(action_id, action)
    if state():can('engage') and input_manager.pop_engagement_intent() then
        respond_to_engagement_intent()
    elseif state():can('walk') then
        if input_manager.has_movement_intent() then
            respond_to_movement_intent()
        end
        update_player_animation()
    end
end

function respond_to_movement_intent()
    local movement_intent = input_manager.get_movement_intent()
    local player_pos = get_player_position()
    local intended_position = position_after_movement(player_pos, movement_intent)
    set_orientation(movement_orientation(movement_intent))
    if Map.position_is_walkable(get_current_map(), intended_position) then
        state():walk(movement_intent)
        animate_movement(function()
            state():halt()
            update_player_animation()
        end)
    elseif Map.is_portal_at(get_current_map(), intended_position) then
        follow_portal(Map.portal_at(get_current_map(), intended_position))
    end
end

local current_text_routine
function respond_to_engagement_intent()
    if not current_text_routine then
        if (Map.position_is_engageable(get_current_map(), position_facing(get_player_position()))) then
            state():engage()
            local engagement_name = Map.get_engagement_at_position(get_current_map(), position_facing(get_player_position()))
            current_text_routine = get_current_texts()[engagement_name]()
        end
    end
    if current_text_routine then
        if text_machine():is("animating") then
            text_machine():skip()
        else
            local status, text = coroutine.resume(current_text_routine)
            if coroutine.status(current_text_routine) == "suspended" then
                text_machine():animate(text)
            else
                text_machine():finish()
                current_text_routine = nil
                state():disengage()
            end
        end
    end
end

function follow_portal(portal)
    portal_animate(
        function()
            state():teleport()
        end,
        function()
            change_current_map(portal.map)
            set_player_position(portal.position.tx, portal.position.ty, portal.position.orientation);
            update_position()
        end,
        function()
            state():appear()
        end
    )
end

function step_animate(frame_interval, fns)
    timer.frames(timers, frame_interval, function()
        fns[1]()
        if #fns > 1 then
            step_animate(frame_interval, _.rest(fns, 2))
        end
    end)
end

function portal_animate(beginning, middle, ending)
    beginning()
    step_animate(5, {
        set_screen_tint_fn(C.SHADE_TINT_3),
        set_screen_tint_fn(C.SHADE_TINT_2),
        set_screen_tint_fn(C.SHADE_TINT_1),
        _.compose(middle, set_screen_tint_fn(C.OFF_TINT)),
        set_screen_tint_fn(C.SHADE_TINT_2),
        set_screen_tint_fn(C.SHADE_TINT_3),
        _.compose(ending, set_screen_tint_fn(C.ON_TINT))
    })
end

function set_screen_tint_fn(tint)
    return function()
        sprite.set_constant("/"..get_current_map_name().."#map", "tint", tint)
        sprite.set_constant("/player#sprite", "tint", tint)
    end
end

function animate_movement(fn)
    local player_pos = get_player_position()
    local pos = go.get_position("/player")
    go.animate("/player", "position.x", go.PLAYBACK_ONCE_FORWARD, tx_to_px(player_pos.tx), go.EASING_LINEAR, 0.27)
    go.animate("/player", "position.y", go.PLAYBACK_ONCE_FORWARD, ty_to_py(player_pos.ty), go.EASING_LINEAR, 0.27, 0, fn)
end

function update_position()
    local player_pos = get_player_position()
    local pos = go.get_position("/player#sprite")
    pos.x = tx_to_px(player_pos.tx)
    pos.y = ty_to_py(player_pos.ty)
    go.set_position(pos, "/player")
end

local current_player_animation_id = "standing_south";
function update_player_animation()
    local disposition = (state():is("walking") or (not state():is("teleporting") and input_manager.has_movement_intent())) and "walking" or "standing"
    local orientation = get_player_position().orientation
    local animation_id = (disposition .. "_" .. orientation)
    if current_player_animation_id == animation_id then return end
    current_player_animation_id = animation_id
    msg.post("/player#sprite", "play_animation", {id = hash(animation_id)})
end

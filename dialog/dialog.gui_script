local timer = require "vendor/timer"
local C = require "main/constants"
local wrap = require "vendor/wrap"
local text_manager = require "managers/text_manager"
local text_machine = text_manager.text_machine()
local timers = {}

function init(self)
    self.dialog_panel_id = gui.get_node("dialog_panel")
    self.dialog_text_id = gui.get_node("dialog_text")
    gui.set_enabled(self.dialog_panel_id, false)
end

function update(self, dt)
    timer.update(timers, dt)
end

function on_message(self, message_id, message, sender)
    if hash("text_machine_state_change") == message_id then
        if message.event == "animate" then
            gui.set_enabled(self.dialog_panel_id, true)
            initialize_text_animation(self, get_current_wrapped_text())
        elseif message.event == "skip" or message.event == "complete" then
            self.text_animation = nil
            gui.set_text(self.dialog_text_id, get_current_wrapped_text())
        elseif message.event == "finish" then
            gui.set_enabled(self.dialog_panel_id, false)
        end
    end
end

function get_current_wrapped_text()
    return wrap(text_manager.get_current_text(), 34)
end

function initialize_text_animation(self, text)
    self.text_animation = coroutine.create(function()
        for i = 1, string.len(text) do
            gui.set_text(self.dialog_text_id, string.sub(text, 0, i))
            coroutine.yield()
        end
    end)
    step_text_animation(self)
end

function step_text_animation(self)
    if not self.text_animation then return end
    if coroutine.status(self.text_animation) == "suspended" then
        coroutine.resume(self.text_animation)
        timer.frames(timers, 2, function() step_text_animation(self) end)
    else
        text_machine:complete()
    end
end
